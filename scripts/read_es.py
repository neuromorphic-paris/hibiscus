import argparse
import eventstream
import struct
import sys

# parse the arguments
parser = argparse.ArgumentParser(description='Read the binary output of the record program and print a text-based representation of the data.')
parser.add_argument('input', help='path to the Event Stream file generated by the record program')
arguments = parser.parse_args()

# loop over all the events and format them
events = eventstream.read(arguments.input)
if events['type'] != 'generic':
    raise Exception('generic events are expected')
for index in range(0, len(events['t'])):
    type = chr(events['bytes'][index][0])
    if type == 's' or type == 'f':
        print('{} {} index: {}'.format(events['t'][index], type, struct.unpack('<L', events['bytes'][index][1:])[0]))
    elif type == 'a' or type == 'b':
        x, y, major_axis, minor_axis = struct.unpack('<ddLL', events['bytes'][index][1:])
        print('{} {} position: ({}, {}), pupil: ({}, {})'.format(
            events['t'][index],
            type,
            x,
            y,
            major_axis / 8192.0,
            minor_axis / 8192.0))
    elif type == 'c':
        t, u = struct.unpack('<QQ', events['bytes'][index][1:])
        print('{} {} t: {}, u: {}'.format(events['t'][index], type, t, u))
    elif type == 'w':
        print('{} {} {}'.format(events['t'][index], type, events['bytes'][index][1:].decode('ascii')))
    else:
        print('{} {}'.format(events['t'][index], type))
